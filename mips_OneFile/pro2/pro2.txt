project2


在这个项目中您将创建一个模拟器pipeline式处理器。你的模拟器应该可以加载指定的MIPS二进制文件并生成逐周期模拟MIPS的二进制代码。它也应该产生/寄存器的内容,打印队列,每个周期和内存数据。异常/中断处理过程中模拟不是必需的。
您可以使用Java或C / c++开发你的模拟器。请跟年底提交政策本文档提交你的源文件。MIPS模拟器(与可执行文件名称MIPSsim)应该接受一个输入文件(inputfilename.txt)下面的命令格式和生成输出文件包含仿真跟踪(simulation.txt)。

正确处理示例输入文件(可能不同的数据值)将被用来确定60%的credit。剩下的40%将来自其他测试用例之前,你不会有访问分级。建议您构建自己的示例输入文件的进一步测试你的模拟器。

Instruction Format:指令格式仍然是项目1中完全一样。请参考项目1的文档。

整个管道由一个时钟信号同步。白色的盒子代表功能单元，单元之间的蓝色框表示队列，黄色框代表寄存器，绿色为内存单元。在本节的其余部分,我们将描述每个单元的功能、队列、内存。我们使用术语"周期的end"和"周期的beginning"在后面的讨论。他们两人参考时钟信号的上升边，也就是前一个周期的结束，意味着下一个周期的开始。

Instruction Fetch/Decode (IF):
获取指令，解码单元最多可以在每个周期获取和解码两个指令(程序顺序)。单位应检查所有下列条件才能获取进一步的指令。
如果获取单元在上个周期停滞（stalled）,无法获取当前指令周期。获取单元可以由于分支指令停滞。
如果在上一个周期最后Pre-issue队列没有空槽,无法获取当前指令周期。

通常情况下,整个fetch-decode操作可以在1周期完成。解码指令将被放置在Pre-issue队列当前的周期结束前。如果一个分支指令获取fetched，,获取的单位将尝试阅读所有必要的寄存器来计算目标地址。如果所有的寄存器都准备好(或目标是直接取址),它将更新PC在当前的周期结束前。否则unit是停滞不前,直到所需的寄存器是可用的。换句话说，如果在上个周期结束前寄存器就绪(或是立即数的值)，分支不引入任何处罚。

有两种可能的场景，当一个分支指令(J,JR,BEQ,BLTZ BGTZ)获取连同另一个指令。分支指令可以这一对指令的第一个指令或后一个(记住,每周期可以获取两个指令)。当获取分支指令与它的下一个指令(第一场景)(顺序)，下一个指令将立即被丢弃(需要再次取出基于分支的结果)。当分支指令是后一个指令(第二场景),，两者都是解码的像往常一样。

请注意，寄存器访问都是同步的。在当前周期的值读取寄存器文件相应的寄存器的值是在前一个周期结束时的。换句话说,任何功能单元无法在同一周期获得新的寄存器值。

break指令时获取,获取单位不会获取任何更多的指令。

所有分支指令，break指令和NOP指令不会被写入Pre-issue队列。重要的是要注意，在fetch单元fetch这些指令之前，我们仍然需要在上个周期free pre-issue队列上的entries，,因为fetch无法在fetch和decode之前预测指令的类型。

pre-issue Queue:
Pre-issue队列:Pre-issue队列中有4项;每个条目可以存储一条指令。指令是按程序顺序排序,entry0总是最久的、entry3包含最新的条目。

issue单元:issue单元单元遵循基本的记分牌算法从寄存器文件读取操作数，当所有源操作数准备发出指令。每循环它可以发出最多两个指令。它最多只能发送一个load或store指令(LW或SW)每周期到Pre-ALU1队列,和一个非loadstore指令(LW或SW除外)每循环到Pre-ALU2队列。当一个指令issued，当前周期结束前它从Pre-issue队列中删除。issue单元在Pre-issue队列搜索从entry0到entry 3(依次)并且issues指令如果:

没有结构性的危害(相关的队列，即Pre-ALU1或Pre-ALU2结束时最后一个周期有空槽),
没有WAW危害(issued但没有finished,或更早的not-issued指令)。
如果两个指令在一个周期中issued，需要确保他们没有WAW或WAR的危险。
与早期not-issued指令没有WAR危害,
MEM指令，所有的源寄存器在上一个周期就绪。
load指令必须等到所有前面的stores issued。
store必须按顺序issue。


Pre-ALU1 queue:这个队列有两个入口，每个可以存一个内存指令和它们的操作数（LW或SW)。队列是FIFO顺序。
Pre-ALU2 queue:这个队列有两个入口，每个可以存储一个ALU指令和操作数（除了LW和SW的任何指令），FIFO。

ALU1:ALU1处理内存地址的计算(LW和SW)指令。ALU1可以每个指令周期从Pre-ALU1队列fetch一个指令，从Pre-ALU1队列删除它(在当前周期开始时)，并计算它,。指令和它的结果将写入Pre - MEM在当前周期的末尾。注意，ALU1开始执行，即使Pre-MEM队列被占用(完整)在当前周期的开始。这是因为MEM保证，消费(删除)Pre-MEM队列的entry，在当前的周期结束前。

ALU2:ALU2处理所有非内存指令的计算。所有的指令采取一个周期。ALU每个周期可以从Pre-ALU2队列fetch一个指令，从Pre-ALU2队列删除它(在当前周期的开始)并计算。指令和其结果将被写入到Post-ALU2在当前周期的末尾。注意，ALU2会开始执行，即使Post-ALU2队列占用(完整)在当前周期的开始。这是因为WB是保证消费(删除)的条目从Post-ALU2队列，在当前的周期结束前。

Post-ALU2队列:此队列有一个entry。这个entry可以存储一条指令与目的寄存器id和结果。
Pre-MEM队列:Pre-MEM队列有一个entry。这个entry可以存储一个内存指令(LW,SW)和操作数。


MEM单位:
MEM单元处理LW和SW指令。它从Pre-MEM队列读取。对LW指令,MEM需要一个周期从内存中读取数据。LW指令结束时,指令和目的寄存器id和数据将被写入Post-MEM队列当前的周期结束前。注意，MEM开始执行，即使在当前周期的开始时Post-MEM队列是满的(全部)。这是因为WB是保证在当前的周期结束前从Post-MEM队列消费(删除)entry。对SW指令，MEM也需要一个周期完成(将数据写入内存)。SW指令完成后，将不会被发送到Post-MEM队列。

Post-MEM队列:Post-MEM队列有一个entry,可以存储一个LW指令与目的寄存器id和数据。

WB Unit:WB单位可以在一个循环中执行两此写回，最多一个来自Post - MEM队列,最多一个来自Post-ALU2队列。它更新寄存器文件基于Post-ALU2队列的内容(LW或SW以外的任何指令)和Post-MEM队列(LW)。更新周期的结束前完成。新值将在下一个循环的开始可用。

PC:它记录下一条指令的地址。它应该在初始化设置为256。

register file:有32个寄存器。假设有足够的读写端口来支持不同的功能单元的各种各样的读写操作。

pipelines需要注意的:
1。break指令fetch时，模拟结束。换句话说,最后一个时钟周期，你打印获取模拟输出是一个break执行指令。
2。没有数据转发。
3。没有延迟槽将用于分支指令。
4。不同的指令需要不同阶段完成
    a。NOP,branch,break:只在IF;
    b。SW:IF, Issue, ALU1, MEM;
    c。LW:IF, Issue, ALU1, MEM, WB;
    d。其他说明:IF Issue,ALU2,WB。

输出格式
对每个周期中，,你应该输出每个周期的结束时的整个处理器的状态和内存。如果一个队列的任何entry是空的，没有内容的entry应该打印出来。指令打印按pro1样式。

不需要任何形式的异常处理。例如，测试用例不会试图执行数据(数据段)指令,或加载/存储指令的数据段。同样没有任何无效的操作码或小于32位指令输入文件,等等。

提交政策:请按照下面提交政策。有10%分数惩罚基于提交违反政策的本质。
1。请提交只有一个源文件。请添加.txt作为文件名后缀。你必须用MIPSsim作文件名(例如,MIPSsim.c。txt或MIPSsim.cpp。txt或MIPSsim.java.txt)。的源文件,请包括这个句子:/ *以我的荣誉担保，我没有考虑也没有收到未经授权的帮助* /。
2。请测试您的提交。我们将遵循这些准确的步骤。
o请命名为MIPSsim编译生成可执行的文件。gcc MIPSsim。c - o MIPSsim或javac MIPSsim。java或g++ MIPSsim。cpp - o MIPSsim啊
o请不要在屏幕上打印东西。哦，请不要硬编码输入文件名，让它作为一个命令行选项。
o请硬编码输出文件名是simulation.txt。”
o执行生成仿真文件和使用正确的，提供一个测试。/ MIPSsim inputfilename。txt或java MIPSsim inputfilename。txt diff - w - b模拟。txt sample_simulation.txt